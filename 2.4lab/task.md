### Функции: необязательные параметры, неопределенное количество параметров

1. <br>а) Напишите функцию `full_name`, которая принимает обязательные параметры `first_name` (имя) и `last_name` (фамилия), а также необязательный параметр `middle_name` (отчество). Функция должна возвращать полное имя человека в формате: если `middle_name` указан: `"Фамилия Имя Отчество"`; если `middle_name` не указан: `"Фамилия Имя"`. *Примеры вызова и возвращаемые результаты:*
<br>`full_name('Иван', 'Петров')` → `'Петров Иван'`
<br>`full_name('Мария', 'Сидорова', middle_name='Алексеевна')` → `'Сидорова Мария Алексеевна'`
<br><br>б) Создайте функцию `transform_list`, которая принимает список чисел `numbers` и необязательный параметр `transform_function`. Если `transform_function` указан, функция должна применить его к каждому элементу списка и вернуть новый список с преобразованными элементами. Если `transform_function` не указан, функция должна вернуть копию исходного списка без изменений. *Примеры вызова и возвращаемые результаты:* <br>`transform_list([1, 2, 3])` → `[1, 2, 3]` <br>`transform_list([1, 2, 3], transform_function=lambda x: x * 2)` → `[2, 4, 6]`
<br><br>в) Напишите функцию `sum_positive_numbers`, которая принимает произвольное количество числовых аргументов и возвращает сумму только положительных чисел из переданных аргументов. *Примеры вызова и возвращаемые результаты:* <br>`sum_positive_numbers(1, -2, 3, -4, 5)` → `9`
<br>`sum_positive_numbers(-1, -2, -3)` → `0`
<br><br>г) Создайте функцию `common_keys`, которая принимает произвольное количество словарей в виде именованных аргументов (например, `dict1`, `dict2` и т.д.) и возвращает новый словарь, содержащий только те ключи и значения, которые присутствуют во всех переданных словарях. *Примеры вызова и возвращаемые результаты:* <br>`common_keys(dict1={'a': 1, 'b': 2}, dict2={'b': 2, 'c': 3})` → `{'b': 2}`
<br>`common_keys(dict1={'x': 5, 'y': 6}, dict2={'y': 6, 'z': 7}, dict3={'y': 6, 'w': 8})` → `{'y': 6}`

2. <br>а) Реализуйте функцию `sort_numbers`, которая принимает список чисел `numbers` и необязательный параметр `reverse_order`. Если `reverse_order` установлен в `True`, функция должна вернуть список, отсортированный по убыванию. Если `reverse_order` не указан или установлен в `False`, функция должна вернуть список, отсортированный по возрастанию. *Примеры вызова и возвращаемые результаты:* <br>`sort_numbers([4, 2, 5, 1, 3])` → `[1, 2, 3, 4, 5]`
<br>`sort_numbers([4, 2, 5, 1, 3], reverse_order=True)` → `[5, 4, 3, 2, 1]`
<br><br>б) Напишите функцию `uppercase_text`, которая принимает обязательный параметр `text` (строка) и необязательный параметр `separator` (символ-разделитель, по умолчанию — пробел). Функция должна разбить строку `text` по разделителю `separator`, преобразовать каждое слово в верхний регистр и вернуть новую строку, в которой слова объединены тем же разделителем. *Примеры вызова и возвращаемые результаты:* <br>`uppercase_text('hello world')` → `'HELLO WORLD'`
<br>`uppercase_text('python,java,c++', separator=',')` → `'PYTHON,JAVA,C++'`
<br><br>в) Создайте функцию `multiply_all`, которая принимает произвольное количество числовых аргументов и возвращает их произведение. *Примеры вызова и возвращаемые результаты:* <br>`multiply_all(1, 2, 3, 4)` → `24`
<br>`multiply_all(5, 10)` → `50`
<br><br>г) Напишите функцию `filter_strings`, которая принимает список строк `strings` и произвольное количество именованных параметров-критериев. Критерии могут быть следующими: `min_length` — минимальная длина строки, `starts_with` — символ или строка, с которой должна начинаться строка, `ends_with` — символ или строка, которой должна оканчиваться строка. Функция должна вернуть новый список строк, удовлетворяющих всем заданным критериям. *Примеры вызова и возвращаемые результаты:* <br>`filter_strings(['яблоко', 'вишня', 'киви'], min_length=6)` → `['яблоко']`
<br>`filter_strings(['test', 'text', 'tent'], starts_with='te', ends_with='t')` → `['test', 'tent']`

3. <br>а) Напишите функцию `split_string`, которая принимает строку `text` и необязательный параметр `delimiter` (по умолчанию — пробел). Функция должна разделить строку `text` по разделителю `delimiter` и вернуть список полученных подстрок. *Примеры вызова и возвращаемые результаты:* <br>`split_string('яблоко виноград дыня')` → `['яблоко', 'виноград', 'дыня']`
<br>`split_string('one,two,three', delimiter=',')` → `['one', 'two', 'three']`
<br><br>б) Создайте функцию `compare_elements`, которая принимает два списка `list1` и `list2`, а также необязательный параметр `comparison_function`. Функция должна сравнить элементы из `list1` и `list2` по индексам, используя `comparison_function`, и вернуть список пар элементов, для которых функция сравнения вернула `True`. Если `comparison_function` не указана, сравнение должно осуществляться на равенство элементов. *Примеры вызова и возвращаемые результаты:* <br>`compare_elements([1, 2, 3], [1, 4, 3])` → `[(1, 1), (3, 3)]`
<br>`compare_elements([1, 2, 3], [4, 5, 6], comparison_function=lambda x, y: x + y > 5)` → `[(2, 5), (3, 6)]`
<br><br>в) Реализуйте функцию `count_unique_chars`, которая принимает произвольное количество строковых аргументов и возвращает общее количество уникальных символов во всех переданных строках. *Примеры вызова и возвращаемые результаты:* <br>`count_unique_chars('hello', 'world')` → `7`
<br>`count_unique_chars('abc', 'def', 'ghi')` → `9`
<br><br>г) Напишите функцию `common_elements`, которая принимает произвольное количество списков и возвращает список элементов, которые присутствуют во всех переданных списках. *Примеры вызова и возвращаемые результаты:* <br>`common_elements([1, 2, 3], [2, 3, 4], [3, 4, 5])` → `[3]`
<br>`common_elements(['a', 'b'], ['b', 'c'], ['b', 'd'])` → `['b']`

4. <br>а) Напишите функцию `calculate`, которая принимает два числа `a` и `b`, а также необязательный параметр `operation`. Параметр `operation` может принимать значения `'add'`, `'subtract'`, `'multiply'`, `'divide'`. Функция должна выполнить указанную операцию над числами `a` и `b`. По умолчанию операция — `'add'`. *Примеры вызова и возвращаемые результаты:* <br>`calculate(10, 5)` → `15`
<br>`calculate(10, 5, operation='multiply')` → `50`
<br><br>б) Реализуйте функцию `modify_strings`, которая принимает список строк `strings` и необязательный параметр `case`. Если `case` установлен в `'upper'`, функция должна вернуть новый список строк в верхнем регистре. Если `case` установлен в `'lower'`, функция должна вернуть новый список строк в нижнем регистре. Если `case` не указан, вернуть исходный список. *Примеры вызова и возвращаемые результаты:* <br>`modify_strings(['Hello', 'World'])` → `['Hello', 'World']`
<br>`modify_strings(['Hello', 'World'], case='upper')` → `['HELLO', 'WORLD']`
<br><br>в) Создайте функцию `average`, которая принимает произвольное количество числовых аргументов и возвращает их среднее значение. *Примеры вызова и возвращаемые результаты:* <br>`average(1, 2, 3, 4, 5)` → `3.0`
<br>`average(10, 20)` → `15.0`
<br><br>г) Напишите функцию `merge_dictionaries`, которая принимает один обязательный словарь и произвольное количество дополнительных словарей в виде именованных аргументов. Функция должна объединить все словари в один, при этом значения ключей из дополнительных словарей должны перезаписывать значения из предыдущих словарей, если ключи совпадают. Верните итоговый объединённый словарь. *Примеры вызова и возвращаемые результаты:* <br>`merge_dictionaries({'a': 1, 'b': 2}, dict1={'b': 3, 'c': 4})` → `{'a': 1, 'b': 3, 'c': 4}`
<br>`merge_dictionaries({'x': 5}, dict1={'y': 6}, dict2={'z': 7})` → `{'x': 5, 'y': 6, 'z': 7}`

5. <br>а) Реализуйте функцию `filter_items`, которая принимает список `items` и необязательный параметр `condition` — функцию-критерий. Функция должна вернуть новый список, содержащий элементы, для которых функция `condition` вернула `True`. Если `condition` не указана, вернуть исходный список. *Примеры вызова и возвращаемые результаты:* <br>`filter_items([1, 2, 3, 4, 5])` → `[1, 2, 3, 4, 5]`
<br>`filter_items([1, 2, 3, 4, 5], condition=lambda x: x > 3)` → `[4, 5]`
<br><br>б) Напишите функцию `merge_and_filter`, которая принимает два списка `list1` и `list2`, а также необязательный параметр `filter_function`. Функция должна объединить оба списка и вернуть новый список, содержащий только элементы, для которых `filter_function` возвращает `True`. Если `filter_function` не указана, вернуть объединённый список без изменений. *Примеры вызова и возвращаемые результаты:* <br>`merge_and_filter([1, 2], [3, 4])` → `[1, 2, 3, 4]`
<br>`merge_and_filter([1, 2], [3, 4], filter_function=lambda x: x % 2 == 0)` → `[2, 4]`
<br><br>в) Создайте функцию `common_in_all`, которая принимает произвольное количество списков и возвращает список элементов, которые присутствуют во всех переданных списках. *Примеры вызова и возвращаемые результаты:* <br>`common_in_all([1, 2, 3], [2, 3, 4], [3, 4, 5])` → `[3]`
<br>`common_in_all(['яблоко', 'вишня'], ['виноград', 'вишня'], ['вишня', 'дыня'])` → `['вишня']`
<br><br>г) Реализуйте функцию `find_primes`, которая принимает произвольное количество числовых аргументов и возвращает список чисел, которые являются простыми числами. *Примеры вызова и возвращаемые результаты:* <br>`find_primes(2, 3, 4, 5, 6, 7)` → `[2, 3, 5, 7]`
<br>`find_primes(10, 15, 17, 19, 23)` → `[17, 19, 23]`

6. <br>а) Напишите функцию `word_count`, которая принимает строку `text` и необязательный параметр `separator` (по умолчанию — пробел). Функция должна разбить строку `text` по разделителю `separator` и вернуть словарь, где ключи — это слова, а значения — количество их вхождений в строку. *Примеры вызова и возвращаемые результаты:* <br>`word_count('один два один')` → `{'один': 2, 'два': 1}`
<br>`word_count('red,green,blue,red', separator=',')` → `{'red': 2, 'green': 1, 'blue': 1}`
<br><br>б) Создайте функцию `filter_numbers`, которая принимает список чисел `numbers` и необязательный параметр `exclude_multiples_of` (число, по умолчанию — `2`). Функция должна вернуть новый список чисел, которые НЕ являются кратными числу `exclude_multiples_of`. *Примеры вызова и возвращаемые результаты:* <br>`filter_numbers([1, 2, 3, 4, 5])` → `[1, 3, 5]`
<br>`filter_numbers([10, 15, 20, 25], exclude_multiples_of=5)` → `[]`
<br><br>в) Реализуйте функцию `merge_and_sort_keys`, которая принимает произвольное количество словарей и возвращает список всех ключей из этих словарей, отсортированных по убыванию их соответствующих значений. Если ключи совпадают, использовать наибольшее значение. *Примеры вызова и возвращаемые результаты:* <br>`merge_and_sort_keys({'a': 2, 'b': 3}, {'a': 5, 'c': 1})` → `['a', 'b', 'c']`
<br>`merge_and_sort_keys({'x': 10}, {'y': 5}, {'z': 15})` → `['z', 'x', 'y']`
<br><br>г) Напишите функцию `sum_non_negative`, которая принимает произвольное количество числовых аргументов и возвращает сумму всех неотрицательных чисел. *Примеры вызова и возвращаемые результаты:* <br>`sum_non_negative(1, -2, 3, -4, 5)` → `9`
<br>`sum_non_negative(-10, -20)` → `0`

7. <br>а) Реализуйте функцию `join_strings`, которая принимает список строк `strings` и необязательный параметр `delimiter` (по умолчанию — запятая). Функция должна объединить элементы списка `strings` в одну строку, разделяя их с помощью `delimiter`. *Примеры вызова и возвращаемые результаты:* <br>`join_strings(['один', 'два', 'три'])` → `'один,два,три'`
<br>`join_strings(['sun', 'moon', 'stars'], delimiter=' | ')` → `'sun | moon | stars'`
<br><br>б) Напишите функцию `combine_lists`, которая принимает два списка `list1` и `list2`, а также необязательный параметр `join_str` (по умолчанию — пустая строка). Функция должна вернуть новый список, где каждый элемент — это конкатенация соответствующих элементов из `list1` и `list2`, разделённых строкой `join_str`. *Примеры вызова и возвращаемые результаты:* <br>`combine_lists(['a', 'b'], ['1', '2'])` → `['a1', 'b2']`
<br>`combine_lists(['x', 'y'], ['10', '20'], join_str='-')` → `['x-10', 'y-20']`
<br><br>в) Создайте функцию `unique_values`, которая принимает произвольное количество аргументов и возвращает список уникальных значений среди них. *Примеры вызова и возвращаемые результаты:* <br>`unique_values(1, 2, 2, 3, 3, 3)` → `[1, 2, 3]`
<br>`unique_values('a', 'b', 'a', 'c', 'b')` → `['a', 'b', 'c']`
<br><br>г) Реализуйте функцию `reverse_concatenate`, которая принимает произвольное количество строковых аргументов и возвращает одну строку, содержащую все входные строки, разделённые пробелом, в обратном порядке. *Примеры вызова и возвращаемые результаты:* <br>`reverse_concatenate('one', 'two', 'three')` → `'three two one'`
<br>`reverse_concatenate('hello', 'world')` → `'world hello'`

8. <br>а) Напишите функцию `pair_and_filter`, которая принимает два списка `list1` и `list2`, а также необязательный параметр `filter_function`. Функция должна создать список из пар элементов `(x, y)`, где `x` из `list1`, а `y` из `list2`, для которых `filter_function(x, y)` возвращает `True`. Если `filter_function` не указан, вернуть все возможные пары. *Примеры вызова и возвращаемые результаты:* <br>`pair_and_filter([1, 2], [3, 4])` → `[(1, 3), (1, 4), (2, 3), (2, 4)]`
<br>`pair_and_filter([1, 2], [3, 4], filter_function=lambda x, y: (x + y) % 2 == 0)` → `[(1, 3), (2, 4)]`
<br><br>б) Создайте функцию `concat_or_upper`, которая принимает список строк `strings` и необязательный параметр `uppercase` (булево значение). Если `uppercase` установлено в `True`, функция должна вернуть одну строку, где все элементы списка соединены пробелом и преобразованы в верхний регистр. Если `uppercase` не указан или установлен в `False`, соединить элементы без изменения регистра. *Примеры вызова и возвращаемые результаты:* <br>`concat_or_upper(['hello', 'world'])` → `'hello world'`
<br>`concat_or_upper(['hello', 'world'], uppercase=True)` → `'HELLO WORLD'`
<br><br>в) Напишите функцию `filter_uppercase_strings`, которая принимает список строк и возвращает новый список, содержащий только те строки, которые полностью состоят из заглавных букв. *Примеры вызова и возвращаемые результаты:* <br>`filter_uppercase_strings(['HELLO', 'World', 'BYE'])` → `['HELLO', 'BYE']`
<br>`filter_uppercase_strings(['Python', 'JAVA', 'c++'])` → `['JAVA']`
<br><br>г) Реализуйте функцию `unique_sorted_elements`, которая принимает произвольное количество списков и возвращает список уникальных элементов из всех списков, отсортированный в порядке возрастания. *Примеры вызова и возвращаемые результаты:* <br>`unique_sorted_elements([3, 1], [2, 3], [1, 4])` → `[1, 2, 3, 4]`
<br>`unique_sorted_elements(['b', 'a'], ['c', 'a'], ['d', 'b'])` → `['a', 'b', 'c', 'd']`

9. <br>а) Создайте функцию `capitalize_words`, которая принимает строку `text` и необязательный параметр `separator` (по умолчанию — пробел). Функция должна разбить строку `text` по разделителю `separator`, преобразовать каждое слово (первая буква — заглавная, остальные — строчные) и вернуть новую строку, объединённую тем же разделителем. *Примеры вызова и возвращаемые результаты:* <br>`capitalize_words('hello world')` → `'Hello World'`
<br>`capitalize_words('python,java,c++', separator=',')` → `'Python,Java,C++'`
<br><br>б) Напишите функцию `filter_elements`, которая принимает два списка `list1` и `list2`, а также необязательный параметр `filter_function`. Функция должна вернуть новый список, содержащий элементы из `list1` и `list2`, для которых `filter_function` возвращает `True`. Если `filter_function` не указан, вернуть все элементы из обоих списков. *Примеры вызова и возвращаемые результаты:* <br>`filter_elements([1, 2, 3], [4, 5, 6])` → `[1, 2, 3, 4, 5, 6]`
<br>`filter_elements([1, 2, 3], [4, 5, 6], filter_function=lambda x: x > 3)` → `[4, 5, 6]`
<br><br>в) Реализуйте функцию `merge_dictionaries`, которая принимает произвольное количество словарей и объединяет их в один. Если ключи совпадают, значение должно быть из последнего словаря, в котором этот ключ встречается. *Примеры вызова и возвращаемые результаты:* <br>`merge_dictionaries({'a': 1}, {'b': 2}, {'a': 3})` → `{'a': 3, 'b': 2}`
<br>`merge_dictionaries({'x': 5}, {'y': 6}, {'z': 7}, {'x': 8})` → `{'x': 8, 'y': 6, 'z': 7}`
<br><br>г) Напишите функцию `unique_keys`, которая принимает произвольное количество словарей и возвращает словарь, содержащий только те ключи и значения, которые не повторяются в других словарях. *Примеры вызова и возвращаемые результаты:* <br>`unique_keys({'a': 1, 'b': 2}, {'b': 3, 'c': 4})` → `{'a': 1, 'c': 4}`
<br>`unique_keys({'x': 5}, {'y': 6}, {'z': 7}, {'x': 8})` → `{'y': 6, 'z': 7}`

10.  
 <br>а) Создайте функцию `filter_numbers`, которая принимает список чисел `numbers` и необязательный параметр `condition`. Параметр `condition` — это функция, которая принимает число и возвращает `True` или `False`. Функция `filter_numbers` должна вернуть новый список, содержащий числа, для которых `condition` вернула `True`. Если `condition` не указана, вернуть исходный список.
 *Примеры вызова и возвращаемые результаты:*
 <br>`filter_numbers([1, 2, 3, 4, 5])` → `[1, 2, 3, 4, 5]`
 <br>`filter_numbers([1, 2, 3, 4, 5], condition=lambda x: x % 2 == 0)` → `[2, 4]`
 <br><br>б) Напишите функцию `transform_numbers`, которая принимает список чисел `numbers` и необязательный параметр `transform_function`. Функция должна применить `transform_function` к каждому элементу и вернуть новый список. Если `transform_function` не указана, вернуть исходный список.
 *Примеры вызова и возвращаемые результаты:*
 <br>`transform_numbers([1, 2, 3])` → `[1, 2, 3]`
 <br>`transform_numbers([1, 2, 3], transform_function=lambda x: x ** 3)` → `[1, 8, 27]`
 <br><br>в) Реализуйте функцию `cube_numbers`, которая принимает произвольное количество числовых списков и возвращает новый список, содержащий кубы всех чисел из всех списков.
 *Примеры вызова и возвращаемые результаты:*
 <br>`cube_numbers([1, 2], [3, 4])` → `[1, 8, 27, 64]`
 <br>`cube_numbers([5], [6, 7], [8])` → `[125, 216, 343, 512]`
 <br><br>г) Напишите функцию `product_non_zero`, которая принимает произвольное количество числовых аргументов и возвращает их произведение, исключая нули.
 *Примеры вызова и возвращаемые результаты:*
 <br>`product_non_zero(1, 2, 0, 4)` → `8`
 <br>`product_non_zero(0, 0, 0)` → `1` (так как нет ненулевых чисел, возвращается мультипликативная единица)

11. <br>а) Напишите функцию `format_strings`, которая принимает список строк `strings` и необязательный параметр `separator` (по умолчанию — пробел `' '`). Функция должна вернуть одну строку, где каждое слово из `strings` начинается с заглавной буквы, а слова соединены через `separator`. *Примеры вызова и возвращаемые результаты:* <br>`format_strings(['hello', 'world'])` → `'Hello World'` <br>`format_strings(['good', 'morning'], separator='-')` → `'Good-Morning'` <br><br>б) Создайте функцию `merge_and_sort`, которая принимает два списка `list1` и `list2`, а также необязательный параметр `sort_function`. Функция должна объединить оба списка и вернуть отсортированный список, используя `sort_function`, если он указан; иначе сортировать по возрастанию. *Примеры вызова и возвращаемые результаты:* <br>`merge_and_sort([3, 1], [4, 2])` → `[1, 2, 3, 4]` <br>`merge_and_sort([3, 1], [4, 2], sort_function=lambda x: -x)` → `[4, 3, 2, 1]` <br><br>в) Реализуйте функцию `concat_all_strings`, которая принимает произвольное количество списков строк и возвращает одну строку, содержащую все строки из входных списков, разделённых запятыми. *Примеры вызова и возвращаемые результаты:* <br>`concat_all_strings(['a', 'b'], ['c', 'd'])` → `'a,b,c,d'` <br>`concat_all_strings(['вишня'], ['банан', 'дыня'], ['киви'])` → `'вишня,банан,дыня,киви'` <br><br>г) Создайте функцию `unique_sorted_strings`, которая принимает произвольное количество строковых аргументов и возвращает список уникальных строк, отсортированных в алфавитном порядке. *Примеры вызова и возвращаемые результаты:* <br>`unique_sorted_strings('виноград', 'яблоко', 'тыква', 'яблоко')` → `['виноград', 'тыква', 'яблоко']` <br>`unique_sorted_strings('x', 'z', 'y', 'x', 'y')` → `['x', 'y', 'z']`

12.  <br>а) Напишите функцию `combine_lists`, которая принимает два списка `list1` и `list2`, а также необязательный параметр `order`, который может быть `'first_second'` или `'second_first'` (по умолчанию — `'first_second'`). Функция должна возвращать объединённый список из `list1` и `list2` в указанном порядке.  *Примеры вызова и возвращаемые результаты:* <br>`combine_lists([1, 2], [3, 4])` → `[1, 2, 3, 4]` <br>`combine_lists([1, 2], [3, 4], order='second_first')` → `[3, 4, 1, 2]` <br><br>б) Реализуйте функцию `process_string`, которая принимает строку `text` и необязательный параметр `separator`. Если `separator` указан, функция должна разбить `text` по этому разделителю, каждое слово преобразовать так, чтобы первая буква была заглавной, остальные — строчными, затем соединить слова обратно с помощью `separator`. Если `separator` не указан, разбить по пробелам и вернуть строку в нижнем регистре.  *Примеры вызова и возвращаемые результаты:* <br>`process_string('HELLO WORLD')` → `'hello world'` <br>`process_string('python_java_c++', separator='_')` → `'Python_Java_C++'` <br><br>в) Создайте функцию `difference`, которая принимает произвольное количество списков и возвращает список элементов, которые присутствуют только в первом списке, но отсутствуют во всех остальных.  *Примеры вызова и возвращаемые результаты:* <br>`difference([1, 2, 3], [2, 3, 4], [3, 4, 5])` → `[1]` <br>`difference(['a', 'b', 'c'], ['b', 'c'], ['c'])` → `['a']` <br><br>г) Напишите функцию `common_in_at_least_two`, которая принимает произвольное количество списков и возвращает список элементов, встречающихся как минимум в двух из них.  *Примеры вызова и возвращаемые результаты:* <br>`common_in_at_least_two([1, 2], [2, 3], [2, 4])` → `[2]` <br>`common_in_at_least_two(['a', 'b'], ['b', 'c'], ['b', 'd'])` → `['b']`

13. <br>а) Реализуйте функцию `divisible_by`, которая принимает список чисел `numbers` и необязательный параметр `divisor` (по умолчанию — `2`). Функция должна вернуть список чисел из `numbers`, которые делятся на `divisor` без остатка.  *Примеры вызова и возвращаемые результаты:* <br>`divisible_by([1, 2, 3, 4, 5])` → `[2, 4]` <br>`divisible_by([10, 15, 20, 25], divisor=5)` → `[10, 15, 20, 25]` <br><br>б) Напишите функцию `transform_numbers`, которая принимает список чисел `numbers` и необязательный параметр `transform_function`. Функция должна вернуть новый список, где каждый элемент — результат применения `transform_function` к числам из `numbers`. Если `transform_function` не указан, удалить из списка все отрицательные числа.  *Примеры вызова и возвращаемые результаты:* <br>`transform_numbers([1, -2, 3, -4])` → `[1, 3]` <br>`transform_numbers([1, 2, 3], transform_function=lambda x: x ** 2)` → `[1, 4, 9]` <br><br>в) Создайте функцию `sorted_values_by_keys`, которая принимает произвольное количество словарей и возвращает список значений из всех словарей, отсортированных по возрастанию их соответствующих ключей.  *Примеры вызова и возвращаемые результаты:* <br>`sorted_values_by_keys({'2': 'b', '1': 'a'}, {'4': 'd', '3': 'c'})` → `['a', 'b', 'c', 'd']` <br>`sorted_values_by_keys({'10': 'j'}, {'5': 'e', '15': 'o'})` → `['e', 'j', 'o']` <br><br>г) Напишите функцию `common_keys_in_dicts`, которая принимает произвольное количество словарей и возвращает словарь, содержащий только те ключи и значения, которые присутствуют во всех словарях, с значениями из последнего словаря, в котором они встречаются.  *Примеры вызова и возвращаемые результаты:* <br>`common_keys_in_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4})` → `{'b': 3}` <br>`common_keys_in_dicts({'x': 5, 'y': 6}, {'y': 7, 'z': 8}, {'y': 9, 'w': 10})` → `{'y': 9}`

14. <br>а) Реализуйте функцию `merge_lists_with`, которая принимает два списка `list1` и `list2`, а также необязательный параметр `merge_function`. Функция должна вернуть новый список, полученный объединением элементов из `list1` и `list2` с использованием `merge_function`. Если `merge_function` не указан, просто объединить списки.  *Примеры вызова и возвращаемые результаты:* <br>`merge_lists_with([1, 2], [3, 4])` → `[1, 2, 3, 4]` <br>`merge_lists_with([1, 2], [3, 4], merge_function=lambda x, y: x + y)` → `[4, 6]` <br><br>б) Создайте функцию `extract_digits`, которая принимает список строк `strings` и необязательный параметр `digits_only` (булево значение). Если `digits_only` установлено в `True`, функция должна вернуть новый список строк, содержащих только цифры из каждой строки. Если `digits_only` не указано или установлено в `False`, вернуть исходный список.  *Примеры вызова и возвращаемые результаты:* <br>`extract_digits(['a1b2', 'c3d4'])` → `['a1b2', 'c3d4']` <br>`extract_digits(['a1b2', 'c3d4'], digits_only=True)` → `['12', '34']` <br><br>в) Напишите функцию `filter_even_numbers`, которая принимает произвольное количество числовых аргументов и возвращает список, содержащий только чётные числа.  *Примеры вызова и возвращаемые результаты:* <br>`filter_even_numbers(1, 2, 3, 4, 5, 6)` → `[2, 4, 6]` <br>`filter_even_numbers(7, 9, 11)` → `[]` <br><br>г) Реализуйте функцию `sorted_positive_numbers`, которая принимает произвольное количество числовых аргументов и возвращает список положительных чисел, отсортированных в порядке убывания.  *Примеры вызова и возвращаемые результаты:* <br>`sorted_positive_numbers(-1, 3, -5, 7, 0)` → `[7, 3]` <br>`sorted_positive_numbers(-10, -20)` → `[]`

15. <br>а) Напишите функцию `change_case`, которая принимает список строк `strings` и необязательный параметр `to_upper` (булево значение). Если `to_upper` установлено в `True`, функция должна вернуть новую строку, где все символы каждой строки из `strings` преобразованы в верхний регистр. Если `to_upper` не указано или установлено в `False`, преобразовать все символы в нижний регистр.  *Примеры вызова и возвращаемые результаты:* <br>`change_case(['Hello', 'World'])` → `'hello world'` <br>`change_case(['Hello', 'World'], to_upper=True)` → `'HELLO WORLD'` <br><br>б) Создайте функцию `filter_combined_lists`, которая принимает два списка `list1` и `list2`, а также необязательный параметр `filter_function`. Функция должна вернуть список элементов из обоих списков, удовлетворяющих `filter_function`. Если `filter_function` не указан, вернуть все элементы из обоих списков.  *Примеры вызова и возвращаемые результаты:* <br>`filter_combined_lists([2, 4], [6, 8])` → `[2, 4, 6, 8]` <br>`filter_combined_lists([2, 4], [6, 8], filter_function=lambda x: x > 5)` → `[6, 8]` <br><br>в) Реализуйте функцию `unique_sorted_numbers`, которая принимает список чисел и возвращает новый список, содержащий только уникальные значения, отсортированные в порядке возрастания.  *Примеры вызова и возвращаемые результаты:* <br>`unique_sorted_numbers([3, 1, 2, 3, 4, 2])` → `[1, 2, 3, 4]` <br>`unique_sorted_numbers([5, 5, 5, 5])` → `[5]` <br><br>г) Напишите функцию `strings_starting_with_upper`, которая принимает произвольное количество строковых аргументов и возвращает список строк, которые начинаются с заглавной буквы.  *Примеры вызова и возвращаемые результаты:* <br>`strings_starting_with_upper('Apple', 'banana', 'Cherry')` → `['Apple', 'Cherry']` <br>`strings_starting_with_upper('dog', 'Elephant', 'fox')` → `['Elephant']`